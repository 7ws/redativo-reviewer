<script>
  // function to insert comments
  function addComments(comments) {
    let result = '';

    if (comments) {
      for (let index = 0; index < comments.length; index++) {
        const evenOrOdd = index % 2 === 0;
        result += `
          <li class="comment" style="text-align: ${evenOrOdd ? 'left' : 'right'}">
            <span class="comment-id">${evenOrOdd ? 'Revisor' : 'Usuário'}</span>
            <p class="comment-text">${comments[index].content}</p>
          </li>
          `
      }
    } else {
      return;
    }

    return result;
  }
</script>

<script>
  // handle current element to be highlighted or opened
  const handleCurrent = (list, id, current) => {
    // scan list
    [...list].map(element => {
      // removes the class that shows the current element from the list
      element.classList.remove(current);
    });

    // adds class that indicates the current element to open or highlight
    [...list][id].classList.add(current);
  };
</script>

<script>
  // handle cards and stickies
  (function () {
    const containerEssay = document.querySelector('.detail');
    // get text element
    let essayText = document.querySelector('.text');

    // split text
    const splittedText = essayText.innerHTML.split('');

    // get comment list element
    const threadListElement = document.querySelector('.threads');

    // function to insert selections in essay text
    function insertSelectedtext(thread) {
      for (let [index, textCharacter] of [...splittedText].entries()) {
        const start = thread.start_text_selection;
        const end = start + thread.selected_text_length;

        // insert span on select start
        if (index === start) {
          splittedText[index] =
            '<span class="selected-text">' + splittedText[index];
        }

        // insert span on select end
        if (index === end) {
          splittedText[index] = splittedText[index] + '</span>';
        }
      }
    }

    let threadIdList = [];

    fetch('{{ threads_url }}')
      .then((res) => res.json())
      .then((data) => {
        data.sort((a, b) => a.start_text_selection - b.start_text_selection);

        for (let [index, thread] of [...data].entries()) {
          threadIdList.push(thread.id);

          // insert selected text into text element
          insertSelectedtext(thread);

          // insert comment card and sticky in list
          // start comment list function
          threadListElement.innerHTML += `
          <li class="thread-container">
            <section class="sticky-note">${index + 1}</section>
            <div class="thread">
              <ul class="comments">
                ${addComments([...thread.comments])}
              </ul>
              <section class="submit-comment-form">
                <textarea class="submit-comment-input" id="submit-comment-input type="text" rows="1" wrap="soft"></textarea>
                <section class="buttons">
                  {% include 'components/button.html' with class='primary-button-small send-response' label='Responder'%}
                  {% include 'components/button.html' with class='secondary-button-small cancel-response' label='Cancelar'%}
                </section>
              </section>
            </div>
          </li>
          `
        }
      })
      .catch(error => {
        console.log('error ' + error);
      })
      .finally(() => {

        // join splitted text and insert into text element
        essayText.innerHTML = splittedText.join('');

        // start listener to sticky element
        handleStickyAndCard();

        // start listener to send comment button
        handleSendComment();
      });

    function handleStickyAndCard() {
      // get comment card list elements
      const commentList = document.querySelectorAll('.thread');
      // get sticky note list elements
      const stickyNoteList = document.querySelectorAll('.sticky-note');
      // get selected text list elements
      const selectedTextList = document.querySelectorAll('.selected-text');

      for (let [index, currentSticky] of [...stickyNoteList].entries()) {
        // wait for sticky note click event
        containerEssay.addEventListener('click', function (event) {
          if (event.target.closest('.current-thread')) {
            // does nothing if this class exists
            return;
          } else if (
            // does nothing if this class exists
            event.target.classList.contains('current-sticky-note')
            ||
            event.target.classList.contains('current-selected-text')
          ) {
            return;
          } else if (
            // does nothing if this class exists
            event.target.classList.contains('sticky-note')
            ||
            event.target.classList.contains('selected-text')
          ) {
            // highlights current selected text
            handleCurrent(selectedTextList, index, 'current-selected-text');
            // scale up current sticky note
            handleCurrent(stickyNoteList, index, 'current-sticky-note');
            // show current comment card
            handleCurrent(commentList, index, 'current-thread');

            let threadContainer = document.querySelector('.current-thread');

            // now make it draggable
            makeDraggable(threadContainer, essayText);
          } else {
            if (window.innerWidth >= 1024) {
              return;
            }
            [...selectedTextList].map(element => {
              // removes the class that shows the current element from the list
              element.classList.remove('current-selected-text');
            });
            [...stickyNoteList].map(element => {
              // removes the class that shows the current element from the list
              element.classList.remove('current-sticky-note');
            });
            [...commentList].map(element => {
              // removes the class that shows the current element from the list
              element.classList.remove('current-thread');
            });
          }
        });
      }
    }

    function handleSendComment() {
      const submitFormList = document.querySelectorAll('.submit-comment-form');
      const comments = document.querySelectorAll('.comments');
      const submitCommentInputList = document.querySelectorAll('.submit-comment-input');
      const sectionButtonList = document.querySelectorAll('.buttons');

      for (let [index, submitForm] of [...submitFormList].entries()) {
        submitForm.addEventListener('click', function (event) {
          if (!event.target.disabled) {
            if (event.target.classList.contains('submit-comment-input')) {
              submitCommentInputList[index].rows = '4';
              sectionButtonList[index].classList.add('buttons-opened');
            }

            if (event.target.classList.contains('cancel-response')) {
              submitCommentInputList[index].rows = '1';
              sectionButtonList[index].classList.remove('buttons-opened');
            }

            if (event.target.classList.contains('send-response')) {
              if (submitCommentInputList[index].value != '') {
                const commentText = submitCommentInputList[index].value
                createComment(commentText, threadIdList[index]);

                comments[index].innerHTML += `
                  <li class="comment" style="text-align: right">
                    <span class="comment-id">Usuário</span>
                    <p class="comment-text">${submitCommentInputList[index].value}</p>
                  </li>
                `
                disableInput()
                sectionButtonList[index].classList.remove('buttons-opened');
              } else {
                console.log('campo vazio');
              }
            }
          }
        })

        const commentElements = comments[index].children;

        for (let [index, comment] of [...commentElements].entries()) {
          if (((index + 1) == commentElements.length)) {
            if (index % 2 != 0) {
              disableInput()
            }
          }
        }

        function disableInput() {
          submitCommentInputList[index].value = '';
          submitCommentInputList[index].rows = '1';
          submitCommentInputList[index].disabled = true;
          submitCommentInputList[index].placeholder = 'Mensagem enviada, aguardando resposta...';
        }
      }
    }

    function createComment(commentText, threadId) {
      if (commentText && threadId) {
        const bodyData = JSON.stringify({
          'content': commentText,
        });

        const requestHeaders = {
          'Content-Type': 'application/json',
          'X-CSRFToken': '{{ csrf_token }}',
        };

        const threadURLTemplate = "{% url 'commenting:comments' thread_id='00000000-0000-0000-0000-000000000000' %}"
        const threadURL = threadURLTemplate.replace('00000000-0000-0000-0000-000000000000', threadId)

        fetch(threadURL, {
          method: 'POST',
          headers: requestHeaders,
          body: bodyData,
        })
          .then(function (response) {
            console.log(response.status);
          }).catch(function (error) {
            console.log(error);
          });
      } else {
        return
      }
    }
  })();
</script>


<script>
  /**
   * Make an element draggable within a container.
   * @param {HTMLElement} el - the element to drag (absolute-positioned .thread-container).
   * @param {HTMLElement} container - the positioned ancestor the el is relative to (e.g. .paper-sheet).
   * @param {Object} [options] - optional settings
   */
  function makeDraggable(el, container, options = {}) {
    // Only enable dragging on small screens
    if (window.innerWidth >= 1024) return;
    centerThreadAtViewport(el, container); // center it initially
    // Use sticky-note as handle if exists, otherwise whole element
    const handle = el;
    handle.style.touchAction = 'none';
    handle.style.cursor = 'grab';

    handle.addEventListener('pointerdown', function onPointerDown(e) {
      if (e.button && e.button !== 0) return; // only left button
      e.preventDefault();

      // measure starting positions
      const containerRect = container.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      const startClientX = e.clientX;
      const startClientY = e.clientY;

      // compute original offset of el relative to container
      const origLeft = elRect.left - containerRect.left + container.scrollLeft;
      const origTop = elRect.top - containerRect.top + container.scrollTop;

      handle.setPointerCapture(e.pointerId);
      handle.style.cursor = 'grabbing';
      el.style.zIndex = 1000; // bring to front while dragging
      document.body.style.userSelect = 'none';

      function onPointerMove(ev) {
        ev.preventDefault();
        // delta in client coords
        const dx = ev.clientX - startClientX;
        const dy = ev.clientY - startClientY;

        let newLeft = origLeft + dx;
        let newTop = origTop + dy;

        // clamp so it stays inside the container (use container.scroll + client dims)
        const maxLeft = container.scrollLeft + container.clientWidth - el.offsetWidth;
        const maxTop = container.scrollTop + container.clientHeight - el.offsetHeight;

        newLeft = Math.max(container.scrollLeft, Math.min(newLeft, maxLeft));
        newTop = Math.max(container.scrollTop, Math.min(newTop, maxTop));

        // apply as px (absolute positioning required)
        el.style.left = `${newLeft}px`;
        el.style.top = `${newTop}px`;
      }

      function onPointerUp(ev) {
        try {handle.releasePointerCapture(ev.pointerId);} catch (_) { }
        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);
        handle.style.cursor = 'grab';
        el.style.zIndex = '';
        document.body.style.userSelect = '';
        // optionally persist position: el.dataset.left = el.style.left; ...
      }

      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
    });

    function centerThreadAtViewport(threadEl, container) {
      // Get viewport center in page coordinates
      const viewportCenterX = window.scrollX + (window.innerWidth / 2);
      const viewportCenterY = window.scrollY + (window.innerHeight / 2);

      // Get container position relative to the page
      const containerRect = container.getBoundingClientRect();
      const containerPageX = window.scrollX + containerRect.left;
      const containerPageY = window.scrollY + containerRect.top;

      // Calculate position relative to container
      let left = viewportCenterX - containerPageX - (threadEl.offsetWidth / 2);
      let top = viewportCenterY - containerPageY - (threadEl.offsetHeight / 2);

      // Clamp so the thread stays inside container bounds
      const maxLeft = container.clientWidth - threadEl.offsetWidth;
      const maxTop = container.clientHeight - threadEl.offsetHeight;

      left = Math.max(0, Math.min(left, maxLeft));
      top = Math.max(0, Math.min(top, maxTop));

      threadEl.style.position = 'absolute';
      threadEl.style.left = `${left}px`;
      threadEl.style.top = `${top}px`;
    }

  }
</script>
